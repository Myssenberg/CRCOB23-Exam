"""Implementation of non-interactive elliptic curve proof of equality

This file contains an elliptic curve implementation of
the proof of equality described on page 9-10, first example in section 5,
in Ivan Damg√•rd's paper "On Sigma-Protocols", however modified to a
non-interactive version using the Fiat-Shamir heuristic.

This file consists of functions that together can be used to run
a full non-interactive proof of knowledge.

This file requires that the environment you are running on have the "petlib", "ZKSK"
and "hashlib" libraries installed.

The file contains the following functions:
    - groupGen: returns the EC group, group order, and group generator
    - keyGen: returns the key pair consisting of secret and two public keys
    - Prover_commitment: returns the two commitments and prover randomness
    - Prover_challenge: returns the challenge
    - Prover_response: returns the response
    - proofGen: returns the generated proof consisting of
                commitments and response
    - verify: returns True or False depending on whether the
              proof was accepted

At the end of the file some examples of how to run a full non-interactive
proof of knowledge as well as how the time taking is done for
the analysis of the project.
These are commented out, but are kept in the file for documentation purposes.
"""

from petlib import ec, bn
from zksk.utils.groups import make_generators
from hashlib import sha256
import time

def groupGen():
    """Generates an EC group, group order and generator

    No args

    Returns:
        group (EcGroup): the EC group from an EC over a finite field
        q (Bn): the group order
        g1, g2 (EcPt): two group generators
    """

    group = ec.EcGroup()
    q = group.order()

    #using the "zksk" library method for getting two different
    #generators for the same EC group
    g1, g2 = make_generators(2, group)

    return group, q, g1, g2

def keyGen(q, g1, g2):
    """Generates a secret and two public keys for Prover using the EC group

    Args:
        q (Bn): the group order
        g1, g2 (EcPt): the two group generators

    Returns:
        w (Bn): the Prover secret key, also called the witness
        h1, h2 (EcPt): the two Prover public keys
    """

    w = q.random()
    h1 = w*g1
    h2 = w*g2

    return w, h1, h2

def Prover_commitment(q, g1, g2):
    """Generates a two Prover commitments (step one in protocol)

    Args:
        q (Bn): the group order
        g1, g2 (EcPt): the two group generators

    Returns:
        a1, a2 (EcPt): the two Prover commitments to randomness r
        r (Bn): randomness
        
    """

    r = q.random()
    a1 = r*g1
    a2 = r*g2

    return a1, a2 , r

def Prover_challenge(g1, g2, h1, h2, a1, a2):
    """Generates a Prover challenge (step two in protocol)
    For non-interactive proofs, the challenge is generated by
    hashing together the public values, g1, g2, h1, h2,
    and the commitments, a1 and a2.

    Args:
        g1, g2 (EcPt): the two group generators
        h1, h2 (EcPt): the two Prover public keys
        a1, a2 (EcPt): the two Prover commitments to randomness r

    Returns:
        e (str): the prover challenge
        
    """

    #hashing the values together and outputting the hex value
    #using the publicly agreed upon hashing function and values
    e = sha256(str(g1+g2+h1+h2+a1+a2).encode()).hexdigest()

    return e

def Prover_response(r, e, w, q):
    """Generates a Prover response (step three in protocol)

    Args:
        r (Bn): randomness
        e (str): Prover challenge
        w (Bn): the Prover witness
        q (Bn): the group order

    Returns:
        z (Bn): the Prover response
        
    """

    #Converting the challenge hex value to a Bn to include
    #in the computation of z
    z = r + bn.Bn.from_hex(e)*w % q

    return z

def proofGen(q, g1, g2, h1, h2, w):
    """Generates the full proof
    commitment, challenge and response

    Args:
        q (Bn): the group order
        g1, g2 (EcPt): the two group generators
        h1, h2 (EcPt): the two Prover public keys
        w (Bn): the Prover witness
        

    Returns:
        a1, a1 (EcPt): the two Prover commitments to randomness r
        z (Bn): the Prover response 
    """
    
    #Prover generates commitment
    commitment1, commitment2, r = Prover_commitment(q, g1, g2)

    #Prover generates challenge
    challenge = Prover_challenge(g1, g2, h1, h2, commitment1, commitment2)

    #Prover generates response.
    response = Prover_response(r, challenge, w, q)

    #Prover "sends" generated proof (commitments and response)
    #to Verifier for verification
    return commitment1, commitment2, response

def verify(group, g1, g2, h1, h2, proof):
    """Verifies the full proof received from the prover

    Args:
        group (EcGroup): the EC group from an EC over a finite field
        g1, g2 (EcPt): the two group generators
        h1, h2 (EcPt): the two Prover public keys
        proof (EcPt, EcPt, Bn): commitment1, commitment2 and response
        
    Returns:
        (bool) : returns true only if all checks are accepted, else false 
    """

    a1, a2, z = proof

    #Verifier generates the challenge
    #using the publicly agreed upon hashing function and values
    e = sha256(str(g1+g2+h1+h2+a1+a2).encode()).hexdigest()
    
    #Verifies that the reponse corresponds with the commitments
    v1 = z*g1 == a1+bn.Bn.from_hex(e)*h1 #Verifies that the reponse corresponds with the commitment
    v2 = z*g2 == a2 + bn.Bn.from_hex(e) * h2
    
    #Checks that the generators and public keys are on the curve
    v_g1 = group.check_point(g1)
    v_h1 = group.check_point(h1)
    v_g2 = group.check_point(g2)
    v_h2 = group.check_point(h2)

    #All checks should be True for the proof to be accepted
    return v1 & v2 & v_g1 & v_g2 & v_h1 & v_h2


#Generation of public knowledge
group, q, g1, g2 = groupGen()

#Prover generates their secret and public keys, "publishing" the public keys
w, h1, h2 = keyGen(q, g1, g2)

startProof = time.process_time_ns()
#Prover generates proof
proof = proofGen(q, g1, g2, h1, h2, w)
finishProof = time.process_time_ns() - startProof

startVerify = time.process_time_ns()
#Verifier "receives" proof and verifies it:
v = verify(group, g1, g2, h1, h2, proof)
finishVerify = time.process_time_ns() - startVerify

print("NIPoE Proof verified:", v)
print("NIPoE Proof Generation time:", finishProof)
print("NIPoE Proof Verification time:", finishVerify)