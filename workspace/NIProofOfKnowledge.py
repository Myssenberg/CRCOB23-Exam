"""Implementation of non-interactive elliptic curve proof of knowledge

This file contains an elliptic curve implementation of
the proof of knowledge described on page 1, first example,
in Ivan Damg√•rd's paper "On Sigma-Protocols", however modified to a
non-interactive version using the Fiat-Shamir heuristic.

This file consists of functions that together can be used to run
a full non-interactive proof of knowledge.

This file requires that the environment you are running on have the "petlib"
and "hashlib" libraries installed.

The file contains the following functions:
    - groupGen: returns the EC group, group order, and group generator
    - keyGen: returns the key pair consisting of secret and public key
    - Prover_commitment: returns the commitment and prover randomness
    - Prover_challenge: returns the challenge
    - Prover_response: returns the response
    - proofGen: returns the generated proof consisting of
                commitment and response
    - verify: returns True or False depending on whether the
              proof was accepted

At the end of the file some examples of how to run a full non-interactive
proof of knowledge as well as how the time taking is done for
the analysis of the project.
These are commented out, but are kept in the file for documentation purposes.
"""

from petlib import ec, bn
from hashlib import sha256

def groupGen():
    """Generates an EC group, group order and generator

    No args

    Returns:
        group (EcGroup): the EC group from an EC over a finite field
        q (Bn): the group order
        g (EcPt): the group generator
    """

    group = ec.EcGroup()
    q = group.order()
    g = group.generator()

    return group, q, g

def keyGen(q, g):
    """Generates a secret and public key for Prover using the EC group

    Args:
        q (Bn): the group order
        g (EcPt): the group generator

    Returns:
        w (Bn): the Prover secret key, also called the witness
        h (EcPt): the Prover public key
    """
    
    w = q.random()
    h = w*g
    
    return w, h

def Prover_commitment(q, g):
    """Generates a Prover commitment (step one in protocol)

    Args:
        q (Bn): the group order
        g (EcPt): the group generator

    Returns:
        a (EcPt): the Prover commitment to randomness r
        r (Bn): randomness
        
    """

    r = q.random()
    a = r*g

    return a, r

def Prover_challenge(g, h, a):
    """Generates a Prover challenge (step two in protocol)
    For non-interactive proofs, the challenge is generated by
    hashing together the public values, g and h, and the commitment, a.

    Args:
        g (EcPt): the group generator
        h (EcPt): the Prover public key
        a (EcPt): the Prover commitment to randomness r

    Returns:
        e (str): the prover challenge
        
    """

    #hashing the values together and outputting the hex value
    #using the publicly agreed upon hashing function and values
    e = sha256(str(g+h+a).encode()).hexdigest()

    return e

def Prover_response(r, e, w, q):
    """Generates a Prover response (step three in protocol)

    Args:
        r (Bn): randomness
        e (str): Prover challenge
        w (Bn): the Prover witness
        q (Bn): the group order

    Returns:
        z (Bn): the Prover response
        
    """

    #Converting the challenge hex value to a Bn to include
    #in the computation of z
    z = r - bn.Bn.from_hex(e)*w % q

    return z

def proofGen(q, g, w, h):
    """Generates the full proof
    commitment, challenge and response

    Args:
        q (Bn): the group order
        g (EcPt): the group generator
        w (Bn): the Prover witness
        h (EcPt): the Prover public key
        

    Returns:
        a (EcPt): the Prover commitment to randomness r
        z (Bn): the Prover response 
    """

    #Prover generates commitment
    commitment, r = Prover_commitment(q, g)

    #Prover generates challenge
    challenge = Prover_challenge(g,h,commitment)

    #Prover generates response.
    response = Prover_response(r, challenge, w, q)

    #Prover "sends" generated proof (commitment and response)
    #to Verifier for verification
    return commitment, response

def verify(group, g, h, proof):
    """Verifies the full proof received from the prover

    Args:
        group (EcGroup): the EC group from an EC over a finite field
        g (EcPt): the group generator
        h (EcPt): the Prover public key
        proof (EcPt, Bn): commitment and response
        
    Returns:
        (bool) : returns true only if all checks are accepted, else false 
    """

    a, z = proof

    #Verifier generates the challenge
    #using the publicly agreed upon hashing function and values
    e = sha256(str(g+h+a).encode()).hexdigest()

    #Verifies that the reponse corresponds with the commitment
    v = a == z*g+bn.Bn.from_hex(e)*h

    #Checks that g and h are on the curve
    g_v = group.check_point(g)
    g_h = group.check_point(h)

    #All checks should be True for the proof to be accepted
    return v & g_v & g_h


#Generation of public knowledge
group, q, g = groupGen()

#Prover generates their secret and public keys, "publishing" the public key
w, h = keyGen(q, g)

#Prover generates proof
proof = proofGen(q, g, w, h)

#Verifier "receives" proof and verifies it:
v = verify(group, g, h, proof)

print("Proof verified:", v)